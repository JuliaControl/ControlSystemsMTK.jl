<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Batch linearization and gain scheduling · ControlSystemsMTK Documentation</title><meta name="title" content="Batch linearization and gain scheduling · ControlSystemsMTK Documentation"/><meta property="og:title" content="Batch linearization and gain scheduling · ControlSystemsMTK Documentation"/><meta property="twitter:title" content="Batch linearization and gain scheduling · ControlSystemsMTK Documentation"/><meta name="description" content="Documentation for ControlSystemsMTK Documentation."/><meta property="og:description" content="Documentation for ControlSystemsMTK Documentation."/><meta property="twitter:description" content="Documentation for ControlSystemsMTK Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ControlSystemsMTK Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Batch linearization and gain scheduling</a><ul class="internal"><li><a class="tocitem" href="#System-model"><span>System model</span></a></li><li><a class="tocitem" href="#Batch-linearization"><span>Batch linearization</span></a></li><li><a class="tocitem" href="#Controller-tuning"><span>Controller tuning</span></a></li><li><a class="tocitem" href="#Gain-scheduling"><span>Gain scheduling</span></a></li><li><a class="tocitem" href="#C-Code-generation"><span>C-Code generation</span></a></li><li><a class="tocitem" href="#Linearize-around-a-trajectory"><span>Linearize around a trajectory</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Batch linearization and gain scheduling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Batch linearization and gain scheduling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystemsMTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystemsMTK.jl/blob/master/docs/src/batch_linearization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Batch-Linearization-and-gain-scheduling"><a class="docs-heading-anchor" href="#Batch-Linearization-and-gain-scheduling">Batch Linearization and gain scheduling</a><a id="Batch-Linearization-and-gain-scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Linearization-and-gain-scheduling" title="Permalink"></a></h1><p>This example will demonstrate how to linearize a nonlinear ModelingToolkit model in multiple different operating points, and some tools to work with groups of linear models representing the same system in different operating points. We&#39;ll end with designing and simulating a <a href="https://en.wikipedia.org/wiki/Gain_scheduling">gain-scheduled controller</a>, i.e., a nonlinear controller created as an interpolation between linear controllers.</p><div class="admonition is-info" id="What-is-an-operating-point?-bc901f6fa1ad1abf"><header class="admonition-header">What is an operating point?<a class="admonition-anchor" href="#What-is-an-operating-point?-bc901f6fa1ad1abf" title="Permalink"></a></header><div class="admonition-body"><p>An operating point is typically understood as a tuple of the form <span>$(x, u)$</span>, where <span>$x$</span> is the state vector and <span>$u$</span> is the input vector. However, we may choose to include <em>parameters</em> <span>$p$</span> in the operating point as well. This may be useful when some parameters are uncertain or time varying, and we want to perform analysis over multiple possible parameter values.</p></div></div><h2 id="System-model"><a class="docs-heading-anchor" href="#System-model">System model</a><a id="System-model-1"></a><a class="docs-heading-anchor-permalink" href="#System-model" title="Permalink"></a></h2><p>The model will be a simple Duffing oscillator:</p><pre><code class="language-julia hljs">using ControlSystemsMTK, ModelingToolkit, MonteCarloMeasurements, ModelingToolkitStandardLibrary.Blocks
unsafe_comparisons(true)

# Create a model
@parameters t k=10 k3=2 c=1
@variables x(t)=0 [bounds = (-0.5, 1.5)]
@variables v(t)=0

D = Differential(t)

@named y = Blocks.RealOutput()
@named u = Blocks.RealInput()

eqs = [D(x) ~ v
       D(v) ~ -k * x - k3 * x^3 - c * v + 10u.u
       y.u ~ x]


@named duffing = System(eqs, t, systems=[y, u])</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} &amp;= v\left( t \right) \\
\frac{\mathrm{d} v\left( t \right)}{\mathrm{d}t} &amp;= 10 \mathtt{u.u}\left( t \right) - c v\left( t \right) - k x\left( t \right) - \left( x\left( t \right) \right)^{3} \mathtt{k3} \\
\mathtt{y.u}\left( t \right) &amp;= x\left( t \right)
\end{align}
 \]</p><h2 id="Batch-linearization"><a class="docs-heading-anchor" href="#Batch-linearization">Batch linearization</a><a id="Batch-linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-linearization" title="Permalink"></a></h2><p>To perform batch linearization, we create a vector of operating points, and then linearize the model around each of these points. The function <a href="../api/#ControlSystemsMTK.batch_ss-Tuple"><code>batch_ss</code></a> does this for us, and returns a vector of <code>StateSpace</code> models, one for each operating point. An operating point is a <code>Dict</code> that maps variables in the MTK model to numerical values. In the example below, we simply sample the variables uniformly within their bounds specified when we created the variables (normally, we might want to linearize on stationary points)</p><pre><code class="language-julia hljs">N = 5 # Number of samples
xs = range(getbounds(x)[1], getbounds(x)[2], length=N)
ops = Dict.(u.u =&gt; 0, x .=&gt; xs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Dict{Num, Real}}:
 Dict(x(t) =&gt; -0.5, u₊u(t) =&gt; 0)
 Dict(x(t) =&gt; 0.0, u₊u(t) =&gt; 0)
 Dict(x(t) =&gt; 0.5, u₊u(t) =&gt; 0)
 Dict(x(t) =&gt; 1.0, u₊u(t) =&gt; 0)
 Dict(x(t) =&gt; 1.5, u₊u(t) =&gt; 0)</code></pre><p>Just like <a href="../api/#ModelingToolkit.linearize"><code>ModelingToolkit.linearize</code></a>, <a href="../api/#ControlSystemsMTK.batch_ss-Tuple"><code>batch_ss</code></a> takes the set of inputs and the set of outputs to linearize between.</p><pre><code class="language-julia hljs">Ps, ssys = batch_ss(duffing, [u.u], [y.u], ops)</code></pre><p>Plotting functions like <a href="../api/#ControlSystemsBase.bodeplot"><code>bodeplot</code></a> accept vectors of systems, so this works</p><pre><code class="language-julia hljs">using ControlSystemsBase, Plots
w = exp10.(LinRange(-2, 3, 200))
bodeplot(Ps, w, legend=false)</code></pre><img src="3fdb6538.svg" alt="Example block output"/><p>We can also convert the vector of system models to a single model with <a href="../api/#RobustAndOptimalControl.ss2particles"><code>RobustAndOptimalControl.ss2particles</code></a>, which will convert the coefficients of the state space models to <a href="https://baggepinnen.github.io/MonteCarloMeasurements.jl/latest/"><code>MonteCarloMeasurements.Particles</code></a> objects.</p><pre><code class="language-julia hljs">using RobustAndOptimalControl
P = RobustAndOptimalControl.ss2particles(Ps) # convert to a single StateSpace system with `Particles` as coefficients.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StateSpace{Continuous, Particles{Float64, 5}}
A = 
 -1.0  -14.5 ± 5.5
  1.0    0.0
B = 
 10.0
  0.0
C = 
 0.0  1.0
D = 
 0.0

Continuous-time state-space model</code></pre><p>notice how some coefficients are plotted like uncertain numbers <code>-13.8 ± 4.3</code>. We can plot such models as well:</p><pre><code class="language-julia hljs">bodeplot(P, w, legend=:bottomright, adaptive=false) # Should look similar to the one above</code></pre><img src="63bfb328.svg" alt="Example block output"/><h2 id="Controller-tuning"><a class="docs-heading-anchor" href="#Controller-tuning">Controller tuning</a><a id="Controller-tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Controller-tuning" title="Permalink"></a></h2><p>Let&#39;s also do some controller tuning for the linearized models above. The function <code>batch_tune</code> is not really required here, but it shows how we might go about building more sophisticated tools for batch tuning. In this example, we will tune a PID controller using the function <a href="../api/#ControlSystemsBase.loopshapingPID"><code>loopshapingPID</code></a>. Note, this procedure is not limited to tuning a gain-scheduled PID controller, it should work for gain-scheduling of any LTI controller. </p><p>!!! &quot;note&quot; Interpolating between controllers     There are multiple ways in which one could interpolate between different controllers. The two most common approaches are to interpolate their outputs, and interpolating their coefficients. When interpolating the coefficients, it is important to ensure that all controllers have the same structure for the interpolation to be meaningful. One may for example interpolate between PID coefficients, or between the coefficients of a state-space model. When interpolating state-space matrices, the systems must all share the same basis, i.e., the state variables must all have the same meaning among the interpolated systems. When converting a transfer function to state-space form, a numerical balancing is performed, this alters the meaning of the state variables and may introduce artificial dynamics to the interpolated system. We thus pass <code>balance=false</code> to the function <code>ss</code> to avoid this, or pick a form explicitly, e.g., <code>modal_form</code>.</p><pre><code class="language-julia hljs">function batch_tune(f, Ps)
    f.(Ps)
end

Cs = batch_tune(Ps) do P
    C, kp, ki, kd, fig, CF = loopshapingPID(P, 7; Mt=1.2, Tf = 1/100)
    ss(CF, balance=false)
    modal_form(ss(CF, balance=true))[1]
end

P = RobustAndOptimalControl.ss2particles(Ps)
C = RobustAndOptimalControl.ss2particles(Cs)

nyquistplot(P * C,
            w,
            ylims = (-10, 2),
            xlims = (-8, 5),
            points = true,
            Ms_circles = [1.5, 2],
            Mt_circles = [1.2])</code></pre><img src="9bad7212.svg" alt="Example block output"/><p>Above, we plotted the Nyquist curve of the loop-transfer function for all system realizations. RobustAndOptimalControl.jl has some facilities for fitting circles around the Nyquist curve for uncertain systems, which we could use here:</p><pre><code class="language-julia hljs">centers, radii = fit_complex_perturbations(P * C, w; relative = false, nominal = :center)
nyquistcircles!(w, centers, radii, ylims = (-5, 1), xlims = (-3, 4))</code></pre><img src="f03ae450.svg" alt="Example block output"/><p>some methods for robust control operate on such circles. Notice how the circles are conservative in many cases, this is typically due to the gain varying between the models for the same phase.</p><p>If you plot the Nyquist curve using the <code>plotly()</code> backend rather than the default <code>gr()</code> backend used here, you can hover the mouse over the curves and see which frequency they correspond to etc. </p><h2 id="Gain-scheduling"><a class="docs-heading-anchor" href="#Gain-scheduling">Gain scheduling</a><a id="Gain-scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Gain-scheduling" title="Permalink"></a></h2><p>Above, we tuned one controller for each operating point, wouldn&#39;t it be nice if we had some features to simulate a <a href="https://en.wikipedia.org/wiki/Gain_scheduling">gain-scheduled controller</a> that interpolates between the different controllers depending on the operating pont? <a href="../api/#ControlSystemsMTK.GainScheduledStateSpace-Tuple{Any, Any}"><code>GainScheduledStateSpace</code></a> is such a thing, we show how to use it below. For fun, we simulate some reference step responses for each individual controller in the array <code>Cs</code> and end with simulating the gain-scheduled controller.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqNonlinearSolve, OrdinaryDiffEqRosenbrock
using DataInterpolations # Required to interpolate between the controllers
@named fb  = Blocks.Add(k2=-1)
@named ref = Blocks.Square(frequency=1/6, amplitude=0.5, offset=0.5, start_time=1)
@named F   = Blocks.SecondOrder(w=15, d=1) # A reference pre-filter
connect    = ModelingToolkit.connect

closed_loop_eqs = [
    connect(ref.output, :r0, F.input)
    connect(F.output,  :r, fb.input1) # Add an analysis point :r
    connect(duffing.y, :y, fb.input2) # Add an analysis point :y
]
plot(layout=2)

# Simulate each individual controller
for C in Cs
    @named Ci = System(C)
    eqs = [
        closed_loop_eqs
        connect(fb.output, Ci.input)
        connect(Ci.output, duffing.u)
    ]
    @named closed_loop = System(eqs, t, systems=[duffing, Ci, fb, ref, F])
    prob = ODEProblem(structural_simplify(closed_loop), [F.x =&gt; 0, F.xd =&gt; 0], (0.0, 8.0))
    sol = solve(prob, Rodas5P(), abstol=1e-8, reltol=1e-8)
    plot!(sol, idxs=[duffing.y.u, duffing.u.u], layout=2, lab=&quot;&quot;)
end

# Simulate gain-scheduled controller
@named Cgs = GainScheduledStateSpace(Cs, xs, interpolator=LinearInterpolation)
eqs = [
    closed_loop_eqs
    connect(fb.output, Cgs.input)
    connect(Cgs.output, :u, duffing.u)
    connect(duffing.y, :v, Cgs.scheduling_input) # Don&#39;t forget to connect the scheduling variable!
]
@named closed_loop = System(eqs, t, systems=[duffing, Cgs, fb, ref, F])
prob = ODEProblem(structural_simplify(closed_loop), [F.xd =&gt; 0], (0.0, 8.0))
sol = solve(prob, Rodas5P(), abstol=1e-8, reltol=1e-8, initializealg=SciMLBase.NoInit(), dtmax=0.01)
plot!(sol, idxs=[duffing.y.u, duffing.u.u], l=(2, :red), lab=&quot;Gain scheduled&quot;)
plot!(sol, idxs=F.output.u, l=(1, :black, :dash, 0.5), lab=&quot;Ref&quot;)</code></pre><img src="b7851242.svg" alt="Example block output"/><p>If everything worked as expected, the gain-scheduled controller should perform reasonably well across the entire scheduling range. </p><h2 id="C-Code-generation"><a class="docs-heading-anchor" href="#C-Code-generation">C-Code generation</a><a id="C-Code-generation-1"></a><a class="docs-heading-anchor-permalink" href="#C-Code-generation" title="Permalink"></a></h2><p>We can generate C-code to interpolate our controller using the function <a href="../api/#SymbolicControlSystems.print_c_array"><code>SymbolicControlSystems.print_c_array</code></a> from <a href="https://github.com/JuliaControl/SymbolicControlSystems.jl">SymbolicControlSystems.jl</a>. If the controller is a standard <a href="../api/#ControlSystemsBase.StateSpace"><code>ControlSystemsBase.StateSpace</code></a> object, a function that filters the input through the controller can be generated by calling <a href="../api/#SymbolicControlSystems.ccode"><code>SymbolicControlSystems.ccode</code></a>. But if the controller is a vector of controllers representing a gain-scheduled controller, a function that creates the interpolated dynamics is written. In the code below, we shorten the vector of controllers to make the generated C-code easier to read by passing <code>Cs[1:3:end]</code> and <code>xs[1:3:end]</code></p><pre><code class="language-julia hljs">using SymbolicControlSystems, ControlSystemsBase
Cs_disc = c2d.(Cs, 0.05, :tustin) # Discretize the controller before generating code
code = SymbolicControlSystems.print_c_array(stdout, Cs_disc[1:3:end], xs[1:3:end], &quot;Cs&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">double Cs_interp_vect[2];
Cs_interp_vect[0] = -0.5;
Cs_interp_vect[1] = 1.0;

double Cs_A[3][3];
Cs_A[0][0] = 1.0;
Cs_A[0][1] = 0.0;
Cs_A[0][2] = 0.0;
Cs_A[1][0] = 0.0;
Cs_A[1][1] = -0.4867631074908737;
Cs_A[1][2] = 0.32780332775069837;
Cs_A[2][0] = 0.0;
Cs_A[2][1] = -0.3278033277506983;
Cs_A[2][2] = -0.48676310749087365;

double Cs_B_interp[3][1][2];
Cs_B_interp[0][0][0] = 0.3531155943158151;
Cs_B_interp[0][0][1] = 0.37434049971517114;
Cs_B_interp[1][0][0] = 3.774581494484414;
Cs_B_interp[1][0][1] = 3.780197210209189;
Cs_B_interp[2][0][0] = -2.4108172908403955;
Cs_B_interp[2][0][1] = -2.414404036706001;

void interpolate_Cs_B(double *Cs_B, double *Cs_B_interp, double *Cs_interp_vect, double t) {
    int k = 0;
    for (k = 0; k &lt; 0; ++k) { // Loop to find correct interval
        if (t &lt; Cs_interp_vect[k+1]) {
            break;
        }
    } // t is now between indices k and k+1 modolu edge cases below
    double t0 = Cs_interp_vect[k];
    double t1 = Cs_interp_vect[k+1];
    double l = t1 - t0;      // Length of interval between points
    double alpha = (t-t0)/l; // Between 0 and 1, proportion of k+1 point
    if (t &lt; Cs_interp_vect[0]) { // edge cases
        alpha = 0;
    }else if (t &gt; Cs_interp_vect[1]) {
        alpha = 1;
    }
    for (int i = 0; i &lt; 3; ++i) {     // Cs_B has dimensions (3, 1)
        for (int j = 0; j &lt; 1; ++j) { // Cs_B_interp has dimensions (3, 1, 2)
            Cs_B[i][j] = (1-alpha)*Cs_B_interp[i][j][k] + alpha*Cs_B_interp[i][j][k+1];
        }
    }
}

double Cs_C_interp[1][3][2];
Cs_C_interp[0][0][0] = 7.062311886316298;
Cs_C_interp[0][0][1] = 7.48680999430341;
Cs_C_interp[0][1][0] = 8.10532803892276;
Cs_C_interp[0][1][1] = 7.818183138865548;
Cs_C_interp[0][2][0] = 31.99882836354859;
Cs_C_interp[0][2][1] = 31.240889205601384;

void interpolate_Cs_C(double *Cs_C, double *Cs_C_interp, double *Cs_interp_vect, double t) {
    int k = 0;
    for (k = 0; k &lt; 0; ++k) { // Loop to find correct interval
        if (t &lt; Cs_interp_vect[k+1]) {
            break;
        }
    } // t is now between indices k and k+1 modolu edge cases below
    double t0 = Cs_interp_vect[k];
    double t1 = Cs_interp_vect[k+1];
    double l = t1 - t0;      // Length of interval between points
    double alpha = (t-t0)/l; // Between 0 and 1, proportion of k+1 point
    if (t &lt; Cs_interp_vect[0]) { // edge cases
        alpha = 0;
    }else if (t &gt; Cs_interp_vect[1]) {
        alpha = 1;
    }
    for (int i = 0; i &lt; 1; ++i) {     // Cs_C has dimensions (1, 3)
        for (int j = 0; j &lt; 3; ++j) { // Cs_C_interp has dimensions (1, 3, 2)
            Cs_C[i][j] = (1-alpha)*Cs_C_interp[i][j][k] + alpha*Cs_C_interp[i][j][k+1];
        }
    }
}

double Cs_D_interp[1][1][2];
Cs_D_interp[0][0][0] = 60.857237577405584;
Cs_D_interp[0][0][1] = 58.98538773339739;

void interpolate_Cs_D(double *Cs_D, double *Cs_D_interp, double *Cs_interp_vect, double t) {
    int k = 0;
    for (k = 0; k &lt; 0; ++k) { // Loop to find correct interval
        if (t &lt; Cs_interp_vect[k+1]) {
            break;
        }
    } // t is now between indices k and k+1 modolu edge cases below
    double t0 = Cs_interp_vect[k];
    double t1 = Cs_interp_vect[k+1];
    double l = t1 - t0;      // Length of interval between points
    double alpha = (t-t0)/l; // Between 0 and 1, proportion of k+1 point
    if (t &lt; Cs_interp_vect[0]) { // edge cases
        alpha = 0;
    }else if (t &gt; Cs_interp_vect[1]) {
        alpha = 1;
    }
    for (int i = 0; i &lt; 1; ++i) {     // Cs_D has dimensions (1, 1)
        for (int j = 0; j &lt; 1; ++j) { // Cs_D_interp has dimensions (1, 1, 2)
            Cs_D[i][j] = (1-alpha)*Cs_D_interp[i][j][k] + alpha*Cs_D_interp[i][j][k+1];
        }
    }
}</code></pre><p>The generated code starts by defining the interpolation vector <code>xs</code>, this variable is called <code>Cs_interp_vect</code> in the generated code. The code then defines all the <span>$A$</span> matrices as a 3-dimensional array, followed by a function that performs the interpolation <code>interpolate_Cs_A</code>. This function takes the output array as the first argument, a pointer to the 3D array with interpolation matrices, the interpolation vector as well as the interpolation variable <code>t</code>, in this document called <span>$v$</span>. The same code is then repeated for the matrices <span>$B,C,D$</span> as well if they require interpolation (if they are all the same, no interpolation code is written). </p><h2 id="Linearize-around-a-trajectory"><a class="docs-heading-anchor" href="#Linearize-around-a-trajectory">Linearize around a trajectory</a><a id="Linearize-around-a-trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#Linearize-around-a-trajectory" title="Permalink"></a></h2><p>We can linearize around a trajectory obtained from <code>solve</code> using the function <a href="../api/#ControlSystemsMTK.trajectory_ss-NTuple{4, Any}"><code>trajectory_ss</code></a>. We provide it with a vector of time points along the trajectory at which to linearize, and in this case we specify the inputs and outputs to linearize between as analysis points <code>r</code> and <code>y</code>.</p><pre><code class="language-julia hljs">timepoints = 0:0.01:8
Ps2, ssys, ops2, resolved_ops = trajectory_ss(closed_loop, closed_loop.r, closed_loop.y, sol; t=timepoints, verbose=true);
bodeplot(Ps2, w, legend=false)</code></pre><img src="b93275de.svg" alt="Example block output"/><p>Not how the closed-loop system changes very little along the trajectory, this is a good indication that the gain-scheduled controller is able to make the system appear linear.</p><p>Internally, <a href="../api/#ControlSystemsMTK.trajectory_ss-NTuple{4, Any}"><code>trajectory_ss</code></a> works very much the same as <a href="../api/#ControlSystemsMTK.batch_ss-Tuple"><code>batch_ss</code></a>, but constructs operating points automatically along the trajectory. This requires that the solution contains the states of the simplified system, accessible through the <code>idxs</code> argument like <code>sol(t, idxs=x)</code>. By linearizing the same system as we simulated, we ensure that this condition holds, doing so requires that we specify the inputs and outputs as analysis points rather than as variables.</p><p>We can replicate the figure above by linearizing the plant and the controller individually, by providing the <code>loop_openings</code> argument. When linearizing the plant, we disconnect the controller input by passing <code>loop_openings=[closed_loop.u]</code>, and when linearizing the controller, we have various options for disconnecting the the plant:</p><ul><li>Break the connection from plant output to controller input by passing <code>loop_openings=[closed_loop.y]</code></li><li>Break the connection between the controller and the plant input by passing <code>loop_openings=[closed_loop.u]</code></li><li>Break the connection <code>y</code> as well as the scheduling variable <code>v</code> (which is another form of feedback) by passing <code>loop_openings=[closed_loop.y, closed_loop.v]</code></li></ul><p>We will explore these options below, starting with the first option, breaking the connection <code>y</code>:</p><pre><code class="language-julia hljs">kwargs = (; adaptive=false, legend=false)
plants, _ = trajectory_ss(closed_loop, closed_loop.u, closed_loop.y, sol; t=timepoints, verbose=true, loop_openings=[closed_loop.u]);
controllersy, ssy, ops3, resolved_ops3 = trajectory_ss(closed_loop, closed_loop.r, closed_loop.u, sol; t=timepoints, verbose=true, loop_openings=[closed_loop.y]);

closed_loopsy = feedback.(plants .* controllersy)
bodeplot(closed_loopsy, w; title=&quot;Loop open at y&quot;, kwargs...)</code></pre><img src="1a90826d.svg" alt="Example block output"/><p>When we open the loop at <code>u</code>, we get a slightly different result:</p><pre><code class="language-julia hljs">controllersu, ssu = trajectory_ss(closed_loop, closed_loop.r, closed_loop.u, sol; t=timepoints, verbose=true, loop_openings=[closed_loop.u]);

closed_loopsu = feedback.(plants .* controllersu)
bodeplot(closed_loopsu, w; title=&quot;Loop open at u&quot;, kwargs...)</code></pre><img src="9527ce2c.svg" alt="Example block output"/><p>In this case, all static gains are 1. A similar result is obtained by explicitly breaking the scheduling feedback <code>v</code> in addition to an opening of <code>y</code>:</p><pre><code class="language-julia hljs">controllersv, ssv = trajectory_ss(closed_loop, closed_loop.r, closed_loop.u, sol; t=timepoints, verbose=true, loop_openings=[closed_loop.y, closed_loop.v]);

closed_loopsv = feedback.(plants .* controllersv)
bodeplot(closed_loopsv, w; title=&quot;Loop open at v and y&quot;, kwargs...)</code></pre><img src="3dd11627.svg" alt="Example block output"/><p>We have thus far treated the controller as a SISO system, but we could also view it as a system with two inputs, the measurement feedback and the scheduling feedback. For completeness, we show below how to derive the corresponding MIMO systems</p><pre><code class="language-julia hljs">plants_mimo, _ = trajectory_ss(closed_loop, closed_loop.u, [closed_loop.y, closed_loop.v], sol; t=timepoints, verbose=true, loop_openings=[closed_loop.u]);
controllers_mimo, ssm = trajectory_ss(closed_loop, [closed_loop.r, closed_loop.v], closed_loop.u, sol; t=timepoints, verbose=true, loop_openings=[closed_loop.u]);

closed_loops_mimo = feedback.(controllers_mimo .* plants_mimo) # Look at complementary sensitivity function in the input, since this is a SISO system
bodeplot(closed_loops_mimo, w; title=&quot;Loop open at MIMO&quot;, kwargs...)</code></pre><img src="4e4f2199.svg" alt="Example block output"/><p>Why are the results different depending on where we open the loop? We can understand the difference by comparing the Bode plots of the controllers. </p><pre><code class="language-julia hljs">plot(
    bodeplot(Cs,           w, legend=false, plotphase=false, title=&quot;Designed controllers&quot;),
    bodeplot(controllersy, w, legend=false, plotphase=false, title=&quot;Loop open at y&quot;),
    bodeplot(controllersu, w, legend=false, plotphase=false, title=&quot;Loop open at u&quot;),
    bodeplot(controllersv, w, legend=false, plotphase=false, title=&quot;Loop open at v and y&quot;),
)</code></pre><img src="9162d6fc.svg" alt="Example block output"/><p>if we open at both <code>y</code> and <code>v</code> or we open at <code>u</code>, we get controllers for the different values of the scheduling variable, and the corresponding measurement feedback (which is the same as the scheduling variable in this case).</p><pre><code class="language-julia hljs">using Test
@test all(sminreal.(controllersv) .== sminreal.(controllersu))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>However, if we only open at <code>y</code> we get controller linearizations that <em>still contain the closed loop through the scheduling connection</em> <code>v</code>. We can verify this by looking at what variables are present in the input-output map</p><pre><code class="language-julia hljs">sminreal(controllersy[end]).x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Symbol}:
 Symbol(&quot;(Cgs₊x(t))[3]&quot;)
 Symbol(&quot;(Cgs₊x(t))[2]&quot;)
 Symbol(&quot;(Cgs₊x(t))[1]&quot;)
 Symbol(&quot;duffing₊v(t)&quot;)
 Symbol(&quot;duffing₊x(t)&quot;)</code></pre><p>notice how the state of the plant is included in the controller, this is an indication that we didn&#39;t fully isolate the controller during the linearizaiton. If we do the same thing for the controller with the loop opened at <code>u</code>, we see that the state of the plant is not included in the controller:</p><pre><code class="language-julia hljs">sminreal(controllersu[end]).x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Symbol}:
 Symbol(&quot;(Cgs₊x(t))[3]&quot;)
 Symbol(&quot;(Cgs₊x(t))[2]&quot;)
 Symbol(&quot;(Cgs₊x(t))[1]&quot;)</code></pre><p>The call to <code>sminreal</code> is important here, it removes the states that are not needed to represent the input-output map of the system. The state of the full model, including the plant state, is present in the linearization before this call. </p><p>The easiest way to ensure that the controller is properly disconnected from the plant while taking into account the different scheduling along the trajectory is thus to break at <code>u</code>.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>We have seen how to</p><ul><li>Perform linearization of a nonlinear ModelingToolkit model in multiple different operating points</li><li>Handle arrays of models or models with <code>Particles</code> as coefficients</li><li>Simulate a gain-scheduled controller that interpolates between linear controllers</li><li>Write C-code to perform the interpolation of the controllers</li></ul><p>Batch linearization in multiple different operating points is an intuitive way to perform analysis of a nonlinear control system. Gain-scheduling is an equally intuitive way of realizing a nonlinear controller. Care should be taken to ensure that the scheduling variable does not change too fast such that the linear assumption at each instance of time is not violated.</p><pre><code class="language-julia hljs">@test sol(6.99, idxs=closed_loop.duffing.y.u) ≈ 0.0 atol=0.01</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 4 July 2025 19:21">Friday 4 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
