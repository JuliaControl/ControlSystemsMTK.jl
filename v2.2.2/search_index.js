var documenterSearchIndex = {"docs":
[{"location":"api/#Exported-functions-and-types","page":"API","title":"Exported functions and types","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Docstrings","page":"API","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [ControlSystemsMTK]\nPrivate = false","category":"page"},{"location":"api/#ModelingToolkit.ODESystem-Tuple{AbstractStateSpace}","page":"API","title":"ModelingToolkit.ODESystem","text":"ModelingToolkit.ODESystem(sys::AbstractStateSpace; name::Symbol, x0 = zeros(sys.nx), x_names, u_names, y_names)\n\nCreate an ODESystem from sys::StateSpace. \n\nArguments:\n\nsys: An instance of StateSpace or NamedStateSpace.\nname: A symbol giving the system a unique name.\nx0: Initial state\n\nThe arguments below are automatically set if the system is a NamedStateSpace.\n\nx_names: A vector of symbols with state names. \nu_names: A vector of symbols with input names. \ny_names: A vector of symbols with output names. \n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsBase.feedback-Tuple{T} where T<:AbstractTimeDependentSystem","page":"API","title":"ControlSystemsBase.feedback","text":"G = ControlSystemsBase.feedback(loopgain::T; name)\n\nForm the feedback-interconnection G = L(1+L)\n\nThe system G will be a new system with input and output connectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.GainScheduledStateSpace-Tuple{Any, Any}","page":"API","title":"ControlSystemsMTK.GainScheduledStateSpace","text":"GainScheduledStateSpace(systems, vt; interpolator, x = zeros((systems[1]).nx), name, u0 = zeros((systems[1]).nu), y0 = zeros((systems[1]).ny))\n\nA linear parameter-varying (LPV) version of Blocks.StateSpace, implementing the following equations:\n\nbeginaligned\ndotx = A(v) x + B(v) u \ny        = C(v) x + D(v) u\nendaligned\n\nwhere v is a scalar scheduling variable.\n\nSee example usage in the gain-scheduling example.\n\nArguments:\n\nsystems: A vector of ControlSystemsBase.StateSpace objects\nvt: A vector of breakpoint values for the scheduling variable v, this has the same length as systems.\ninterpolator: A constructor i = interpolator(values, breakpoints) and returns an interpolator object that can be called like i(v) to get the interpolated value at v. LinearInterpolation from DataInterpolations.jl is a good choice, but a lookup table can also be used.\n\nConnectors\n\ninput of type RealInput connects to u.\noutput of type RealOutput connects to y.\nscheduling_input of type RealInput connects to v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.batch_ss-Tuple","page":"API","title":"ControlSystemsMTK.batch_ss","text":"batch_ss(sys, inputs, outputs, ops::AbstractVector{<:AbstractDict};\n            t = 0.0,\n            allow_input_derivatives = false,\n            kwargs...)\n\nLinearize sys in multiple operating points ops::Vector{Dict}. Returns a vector of StateSpace objects and the simplified system.\n\nExample:\n\nusing ControlSystemsMTK, ModelingToolkit, RobustAndOptimalControl\nusing ModelingToolkit: getdefault\nunsafe_comparisons(true)\n\n# Create a model\n@parameters t k=10 k3=2 c=1\n@variables x(t)=0 [bounds = (-2, 2)]\n@variables v(t)=0\n@variables u(t)=0\n@variables y(t)=0\n\nD = Differential(t)\n\neqs = [D(x) ~ v\n       D(v) ~ -k * x - k3 * x^3 - c * v + 10u\n       y ~ x]\n\n\n@named duffing = ODESystem(eqs, t)\n\nbounds = getbounds(duffing, unknowns(duffing))\nsample_within_bounds((l, u)) = (u - l) * rand() + l\n# Create a vector of operating points\nops = map(1:N) do i\n    op = Dict(x => sample_within_bounds(bounds[x]) for x in keys(bounds) if isfinite(bounds[x][1]))\nend\n\nPs, ssys = batch_ss(duffing, [u], [y], ops)\nw = exp10.(LinRange(-2, 2, 200))\nbodeplot(Ps, w)\nP = RobustAndOptimalControl.ss2particles(Ps) # convert to a single StateSpace system with `Particles` as coefficients.\nbodeplot(P, w) # Should look similar to the one above\n\nLet's also do some tuning for the linearized models above\n\nfunction batch_tune(f, Ps)\n    f.(Ps)\nend\n\nCs = batch_tune(Ps) do P\n    # C, kp, ki, fig, CF = loopshapingPI(P, 6; phasemargin=45)\n    C, kp, ki, kd, fig, CF = loopshapingPID(P, 6; Mt=1.3, Tf = 1/100)\n    ss(CF)\nend\n\nP = RobustAndOptimalControl.ss2particles(Ps)\nC = RobustAndOptimalControl.ss2particles(Cs)\n\nnyquistplot(P * C,\n            w,\n            ylims = (-10, 3),\n            xlims = (-5, 10),\n            points = true,\n            Ms_circles = [1.5, 2],\n            Mt_circles = [1.5, 2])\n\n# Fit circles that encircle the Nyquist curve for each frequency\ncenters, radii = fit_complex_perturbations(P * C, w; relative = false, nominal = :center)\nnyquistcircles!(w, centers, radii, ylims = (-4, 1), xlims = (-3, 4))\n\nSee also trajectory_ss and fuzz.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.build_quadratic_cost_matrix-Tuple{NamedTuple, ODESystem, AbstractVector{<:Pair}}","page":"API","title":"ControlSystemsMTK.build_quadratic_cost_matrix","text":"build_quadratic_cost_matrix(linear_sys, ssys::ODESystem, costs::Vector{Pair})\n\nFor a system that has been linearized, assemble a quadratic cost matrix (for LQR or Kalman filtering) that penalizes states or outputs of simplified system ssys according to the vector of pairs costs.\n\nThe motivation for this function is that ModelingToolkit does not guarantee\n\nWhich states are selected as states after simplification.\nThe order of the states.\n\nThe second problem above, the ordering of the states, can be worked around using reorder_states, but the first problem cannot be solved by trivial reordering. This function thus accepts an array of costs for a user-selected state realization, and assembles the correct cost matrix for the state realization selected by MTK. To do this, the funciton needs the linearization (linear_sys) as well as the simplified system, both of which are outputs of linearize.\n\nArguments:\n\nlinear_sys: Output of linearize, an object containing a property called C. This can be a ControlSystemsBase.StateSpace or a NamedTuple with a field C.\nssys: Output of linearize.\ncosts: A vector of pairs\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.build_quadratic_cost_matrix-Tuple{ODESystem, AbstractVector, AbstractVector{<:Pair}}","page":"API","title":"ControlSystemsMTK.build_quadratic_cost_matrix","text":"build_quadratic_cost_matrix(sys::ODESystem, inputs::Vector, costs::Vector{Pair}; kwargs...)\n\nAssemble a quadratic cost matrix (for LQR or Kalman filtering) that penalizes states or outputs of system sys according to the vector of pairs costs.\n\nThe motivation for this function is that ModelingToolkit does not guarantee\n\nWhich states are selected as states after simplification.\nThe order of the states.\n\nThe second problem above, the ordering of the states, can be worked around using reorder_states, but the first problem cannot be solved by trivial reordering. This function thus accepts an array of costs for a user-selected state realization, and assembles the correct cost matrix for the state realization selected by MTK. To do this, the funciton performs a linearization between inputs and the cost outputs. The linearization is used to determine the matrix entries belonging to states that are not part of the realization chosen by MTK.\n\nArguments:\n\nsys: The system to be linearized (not simplified).\ninputs: A vector of variables that are to be considered controlled inputs for the LQR controller.\ncosts: A vector of pairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.get_named_comp_sensitivity","page":"API","title":"ControlSystemsMTK.get_named_comp_sensitivity","text":"get_named_comp_sensitivity(sys, ap::AnalysisPoint; kwargs...)\nget_named_comp_sensitivity(sys, ap_name::Symbol; kwargs...)\n\nCall ModelingToolkitStandardLibrary.Blocks.get_comp_sensitivity while retaining signal names. Returns a NamedStateSpace object (similar to named_ss).\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemsMTK.get_named_looptransfer","page":"API","title":"ControlSystemsMTK.get_named_looptransfer","text":"get_named_looptransfer(sys, ap::AnalysisPoint; kwargs...)\nget_named_looptransfer(sys, ap_name::Symbol; kwargs...)\n\nCall ModelingToolkitStandardLibrary.Blocks.get_looptransfer while retaining signal names. Returns a NamedStateSpace object (similar to named_ss).\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemsMTK.get_named_sensitivity","page":"API","title":"ControlSystemsMTK.get_named_sensitivity","text":"get_named_sensitivity(sys, ap::AnalysisPoint; kwargs...)\nget_named_sensitivity(sys, ap_name::Symbol; kwargs...)\n\nCall ModelingToolkitStandardLibrary.Blocks.get_sensitivity while retaining signal names. Returns a NamedStateSpace object (similar to named_ss).\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemsMTK.sconnect-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractTimeDependentSystem","page":"API","title":"ControlSystemsMTK.sconnect","text":"sconnect(sys1::T, sys2::T; name)\n\nConnect systems in series, equivalent to sys2*sys1 or series(sys1, sys2) in ControlSystems.jl terminology\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.sconnect-Union{Tuple{T}, Tuple{Union{Function, Num}, T}} where T<:AbstractTimeDependentSystem","page":"API","title":"ControlSystemsMTK.sconnect","text":"sconnect(input::Function, sys::T; name)\nsconnect(input::Num,      sys::T; name)\n\nConnect a function input(t) to sys.input\n\nExamples:\n\nsconnect(sin, sys)   # Connect a funciton, assumed to be a function of time\nsconnect(sin(t), sys) # Connect a Num\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemsMTK.trajectory_ss-NTuple{4, Any}","page":"API","title":"ControlSystemsMTK.trajectory_ss","text":"linsystems, ssys = trajectory_ss(sys, inputs, outputs, sol; t = _max_100(sol.t), fuzzer=nothing, verbose = true, kwargs...)\n\nLinearize sys around the trajectory sol at times t. Returns a vector of StateSpace objects and the simplified system.\n\nArguments:\n\ninputs: A vector of variables or analysis points.\noutputs: A vector of variables or analysis points.\nsol: An ODE solution object. This solution must contain the states of the simplified system, accessible through the idxs argument like sol(t, idxs=x).\nt: Time points along the solution trajectory at which to linearize. The returned array of StateSpace objects will be of the same length as t.\nfuzzer: A function that takes an operating point dictionary and returns an array of \"fuzzed\" operating points. This is useful for adding noise/uncertainty to the operating points along the trajectory. See ControlSystemsMTK.fuzz for such a function.\nverbose: If true, print warnings for variables that are not found in sol.\nkwargs: Are sent to the linearization functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#RobustAndOptimalControl.named_ss-Tuple{AbstractTimeDependentSystem, Any, Any}","page":"API","title":"RobustAndOptimalControl.named_ss","text":"RobustAndOptimalControl.named_ss(sys::ModelingToolkit.AbstractTimeDependentSystem, inputs, outputs; kwargs...)\n\nConvert an ODESystem to a NamedStateSpace using linearization. inputs, outputs are vectors of variables determining the inputs and outputs respectively. See docstring of ModelingToolkit.linearize for more info on kwargs.\n\nThis method automatically converts systems that MTK has failed to produce a proper form for into a proper linear statespace system. Learn more about how that is done here: https://juliacontrol.github.io/ControlSystemsMTK.jl/dev/#Internals:-Transformation-of-non-proper-models-to-proper-statespace-form\n\nSee also ModelingToolkit.linearize which is the lower-level function called internally. The functions get_named_sensitivity, get_named_comp_sensitivity, get_named_looptransfer similarily provide convenient ways to compute sensitivity functions while retaining signal names in the same way as named_ss. The corresponding lower-level functions get_sensitivity, get_comp_sensitivity and get_looptransfer are available in ModelingToolkitStandardLibrary.Blocks and are documented in MTKstdlib: Linear analysis.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"bodeplot\nlinearize\nlinearization_function\nloopshapingPID\nnamed_ss\nget_named_sensitivity\nget_named_comp_sensitivity\nget_named_looptransfer\nModelingToolkit.linearize_symbolic\nModelingToolkitStandardLibrary.Blocks.get_sensitivity\nModelingToolkitStandardLibrary.Blocks.get_comp_sensitivity\nModelingToolkitStandardLibrary.Blocks.get_looptransfer\nModelingToolkitStandardLibrary.Blocks.StateSpace\nRobustAndOptimalControl.ss2particles\nControlSystemsBase.StateSpace\nSymbolicControlSystems.ccode\nSymbolicControlSystems.print_c_array\nModelingToolkit.reorder_states\nControlSystemsMTK.fuzz","category":"page"},{"location":"api/#ControlSystemsBase.bodeplot","page":"API","title":"ControlSystemsBase.bodeplot","text":"fig = bodeplot(sys, args...)\nbodeplot(LTISystem[sys1, sys2...], args...; plotphase=true, balance = true, kwargs...)\n\nCreate a Bode plot of the LTISystem(s). A frequency vector w can be optionally provided. To change the Magnitude scale see setPlotScale. The default magnitude scale is \"log10\" (absolute scale).\n\nIf hz=true, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.\nbalance: Call balance_statespace on the system before plotting.\n\nkwargs is sent as argument to RecipesBase.plot.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.linearize","page":"API","title":"ModelingToolkit.linearize","text":"(; A, B, C, D), simplified_sys = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)\n(; A, B, C, D)                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)\n\nLinearize sys between inputs and outputs, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form\n\nbeginaligned\nx = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nzero_dummy_der can be set to automatically set the operating point to zero for all dummy derivatives.\n\nSee also linearization_function which provides a lower-level interface, linearize_symbolic and ModelingToolkit.reorder_unknowns.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    ODESystem(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input = true]\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    ODESystem(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    ODESystem(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = ODESystem(connections, t, systems = [f, c, p])\n\nlsys0, ssys = linearize(cl, [f.u], [p.x])\ndesired_order = [f.x, p.x]\nlsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\n## Symbolic linearization\nlsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])\n\n@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A\n\n\n\n\n\nModelingToolkit.linearize(sys, input_name::Symbol, output_name; kwargs...)\n\nLinearize a system between two analysis points. To get a loop-transfer function, see get_looptransfer.\n\nThe output is allowed to be either an analysis-point name, or a vector of symbolic variables like the standard interface to linearize. The input must be an analysis-point name.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.linearization_function","page":"API","title":"ModelingToolkit.linearization_function","text":"lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, initialize = true, initialization_solver_alg = TrustRegion(), kwargs...)\n\nReturn a function that linearizes the system sys. The function linearize provides a higher-level and easier to use interface.\n\nlin_fun is a function (variables, p, t) -> (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u), i.e., it returns a NamedTuple with the Jacobians of f,g,h for the nonlinear sys (technically for simplified_sys) on the form\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs. To obtain a linear statespace representation, see linearize. The input argument variables is a vector defining the operating point, corresponding to unknowns(simplified_sys) and p is a vector corresponding to the parameters of simplified_sys. Note: all variables in inputs have been converted to parameters in simplified_sys.\n\nThe simplified_sys has undergone structural_simplify and had any occurring input or output variables replaced with the variables provided in arguments inputs and outputs. The unknowns of this system also indicate the order of the unknowns that holds for the linearized matrices.\n\nArguments:\n\nsys: An ODESystem. This function will automatically apply simplification passes on sys and return the resulting simplified_sys.\ninputs: A vector of variables that indicate the inputs of the linearized input-output model.\noutputs: A vector of variables that indicate the outputs of the linearized input-output model.\nsimplify: Apply simplification in tearing.\ninitialize: If true, a check is performed to ensure that the operating point is consistent (satisfies algebraic equations). If the op is not consistent, initialization is performed.\ninitialization_solver_alg: A NonlinearSolve algorithm to use for solving for a feasible set of state and algebraic variables that satisfies the specified operating point.\nkwargs: Are passed on to find_solvables!\n\nSee also linearize which provides a higher-level interface.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemsBase.loopshapingPID","page":"API","title":"ControlSystemsBase.loopshapingPID","text":"C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt = 1.3, ϕt=75, form=:standard, doplot=false, lb=-10, ub=10, Tf = 1/1000ω, F = nothing)\n\nSelects the parameters of a PID-controller such that the Nyquist curve of the loop-transfer function L = PC at the frequency ω is tangent to the circle where the magnitude of T = PC  (1+PC) equals Mt. ϕt denotes the positive angle in degrees between the real axis and the tangent point.\n\nThe default values for Mt and ϕt are chosen to give a good design for processes with inertia, and may need tuning for simpler processes.\n\nThe gain of the resulting controller is generally increasing with increasing ω and Mt.\n\nArguments:\n\nP: A SISO plant.\nω: The specification frequency.\nMt: The magnitude of the complementary sensitivity function at the specification frequency, T(iω).\nϕt: The positive angle in degrees between the real axis and the tangent point.\ndoplot: If true, gang of four and Nyquist plots will be returned in fig.\nlb: log10 of lower bound for kd.\nub: log10 of upper bound for kd.\nTf: Time constant for second-order measurement noise filter on the form tf(1, [Tf^2, 2*Tf/sqrt(2), 1]) to make the controller strictly proper. A practical controller typically sets this time constant slower than the default, e.g., Tf = 1/100ω or Tf = 1/10ω\nF: A pre-designed filter to use instead of the default second-order filter.\n\nThe parameters can be returned as one of several common representations  chosen by form, the options are\n\n:standard - K_p(1 + 1(T_i s) + T_ds)\n:series - K_c(1 + 1(τ_i s))(τ_d s + 1)\n:parallel - K_p + K_is + K_d s\n\nSee also loopshapingPI, pidplots, stabregionPID and placePI.\n\nExample:\n\nP  = tf(1, [1,0,0]) # A double integrator\nMt = 1.3  # Maximum magnitude of complementary sensitivity\nω  = 1    # Frequency at which the specification holds\nC, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt, ϕt = 75, doplot=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#RobustAndOptimalControl.named_ss","page":"API","title":"RobustAndOptimalControl.named_ss","text":"RobustAndOptimalControl.named_ss(sys::ModelingToolkit.AbstractTimeDependentSystem, inputs, outputs; kwargs...)\n\nConvert an ODESystem to a NamedStateSpace using linearization. inputs, outputs are vectors of variables determining the inputs and outputs respectively. See docstring of ModelingToolkit.linearize for more info on kwargs.\n\nThis method automatically converts systems that MTK has failed to produce a proper form for into a proper linear statespace system. Learn more about how that is done here: https://juliacontrol.github.io/ControlSystemsMTK.jl/dev/#Internals:-Transformation-of-non-proper-models-to-proper-statespace-form\n\nSee also ModelingToolkit.linearize which is the lower-level function called internally. The functions get_named_sensitivity, get_named_comp_sensitivity, get_named_looptransfer similarily provide convenient ways to compute sensitivity functions while retaining signal names in the same way as named_ss. The corresponding lower-level functions get_sensitivity, get_comp_sensitivity and get_looptransfer are available in ModelingToolkitStandardLibrary.Blocks and are documented in MTKstdlib: Linear analysis.\n\n\n\n\n\nnamed_ss(sys::AbstractStateSpace{T}; x, u, y)\n\nCreate a NamedStateSpace system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs.\n\nIf a single name is provided but a vector of names is expected, this name will be used as prefix followed by a numerical index.\nIf no name is provided, default names (x,y,u) will be used.\n\nArguments:\n\nsys: A system to add names to.\nx: A list of symbols with names of the states.\nu: A list of symbols with names of the inputs.\ny: A list of symbols with names of the outputs.\n\nExample\n\nG1 = ss(1,1,1,0)\nG2 = ss(1,1,1,0)\ns1 = named_ss(G1, x = :x, u = :u1, y=:y1)\ns2 = named_ss(G2, x = :z, u = :u2, y=:y2)\n\ns1[:y1, :u1] # Index using symbols. Uses prefix matching if no exact match is found.\n\nfb = feedback(s1, s2, r = :r) # \n\n\n\n\n\nnamed_ss(sys::AbstractStateSpace, name; x, y, u)\n\nIf a single name of the system is provided, the outputs, inputs and states will be automatically named y,u,x with name as prefix.\n\n\n\n\n\nnamed_ss(sys::ExtendedStateSpace;       kwargs...)\nnamed_ss(sys::ExtendedStateSpace, name; kwargs...)\n\nAssign names to an ExtendedStateSpace. If no specific names are provided for signals z,y,w,u and statesx, names will be generated automatically.\n\nArguments:\n\nname: Prefix to add to all automatically generated names.\nx\nu\ny\nw\nz\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.linearize_symbolic","page":"API","title":"ModelingToolkit.linearize_symbolic","text":"(; A, B, C, D), simplified_sys = linearize_symbolic(sys::AbstractSystem, inputs, outputs; simplify = false, allow_input_derivatives = false, kwargs...)\n\nSimilar to linearize, but returns symbolic matrices A,B,C,D rather than numeric. While linearize uses ForwardDiff to perform the linearization, this function uses Symbolics.jacobian.\n\nSee linearize for a description of the arguments.\n\nExtended help\n\nThe named tuple returned as the first argument additionally contains the jacobians f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u of\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkitStandardLibrary.Blocks.get_sensitivity","page":"API","title":"ModelingToolkitStandardLibrary.Blocks.get_sensitivity","text":"get_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkitStandardLibrary.Blocks.get_comp_sensitivity","page":"API","title":"ModelingToolkitStandardLibrary.Blocks.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkitStandardLibrary.Blocks.get_looptransfer","page":"API","title":"ModelingToolkitStandardLibrary.Blocks.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkitStandardLibrary.Blocks.StateSpace","page":"API","title":"ModelingToolkitStandardLibrary.Blocks.StateSpace","text":"StateSpace(A, B, C, D = 0; x = zeros(size(A,1)), u0 = zeros(size(B,2)), y0 = zeros(size(C,1)), name)\n\nA linear, time-invariant state-space system on the form.\n\nbeginaligned\nx = Ax + Bu \ny = Cx + Du\nendaligned\n\nTransfer functions can also be simulated by converting them to a StateSpace form.\n\ny0 and u0 can be used to set an operating point, providing them changes the dynamics from an LTI system to the affine system\n\nbeginaligned\nx = Ax + B(u - u0) \ny = Cx + D(u - u0) + y0\nendaligned\n\nFor a nonlinear system\n\nbeginaligned\nx = f(x u) \ny = h(x u)\nendaligned\n\nlinearized around the operating point x₀, u₀, we have y0, u0 = h(x₀, u₀), u₀.\n\n\n\n\n\n","category":"function"},{"location":"api/#RobustAndOptimalControl.ss2particles","page":"API","title":"RobustAndOptimalControl.ss2particles","text":"ss2particles(G::Vector{<:AbstractStateSpace})\n\nConverts a vector of state space models to a single state space model with coefficient type MonteCarloMeasurements.Particles.\n\nSee also sys_from_particles.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemsBase.StateSpace","page":"API","title":"ControlSystemsBase.StateSpace","text":"StateSpace{TE, T} <: AbstractStateSpace{TE}\n\nAn object representing a standard state space system.\n\nSee the function ss for a user facing constructor as well as the documentation page creating systems.\n\nFields:\n\nA::Matrix{T}\nB::Matrix{T}\nC::Matrix{T}\nD::Matrix{T}\ntimeevol::TE\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicControlSystems.ccode","page":"API","title":"SymbolicControlSystems.ccode","text":"ccode(G; simplify = identity, cse = true)\n\nReturn a string with C-code for filtering a signal u through G. \n\nIf G is a transfer function, the system must be SISO, for MIMO systems, use a StateSpace model instead.\n\nWith a transfer function as input, the code will return a double corresponding to the single output. With a StateSpace model as input, the code will produce a function that takes a double pointer double *y as the first input argument. Make sure that y points to an array of length G.ny before calling the function.\n\nThe state is internally handled by C static variables, so the generated code is thus stateful. \n\nArguments:\n\nG: A linear system\nsimplify: A function for symbolic simplification. You may try Sympy.simplify, but for large systems, this will take a long time to compute.\ncse: Perform common subexpression elimination. This generally improves the performance of the generated code.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicControlSystems.print_c_array","page":"API","title":"SymbolicControlSystems.print_c_array","text":"print_c_array(io, a::Vector{<:AbstractArray}, t::AbstractVector, name = \"mat\"; cse = false, s = \"\", print_vector = true, print_logic = true, struct_name::Union{Nothing, String} = nothing, struct_type = nothing, ivecname = name * \"_interp_vect\")\n\nWrite C-code for interpolating between arrays a. The array t contains the interpolation points.\n\n\n\n\n\nprint_c_array(io, sys::Vector{<:AbstractStateSpace}, t::AbstractVector, name = \"sys\"; cse = false, s = \"\", en = \"\", struct_name::Union{Nothing, String} = nothing, struct_type = nothing)\n\nWrite C-code for an interpolated linear system. The interpolation vector t defines the interpolation points, this vector is expected to be of the same length as the vector of linear systems sys. \n\ns, en: are strings that are appended at the start and end of variables names in the C-code.\nstruct_name: If provided, the interpolation matrices will be placed inside a struct with this name.\nstruct_type: If the struct name is used, provide also the C type of the struct.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemsMTK.fuzz","page":"API","title":"ControlSystemsMTK.fuzz","text":"fuzz(op, p; N = 10, parameters = true, variables = true)\n\n\"Fuzz\" an operating point op::Dict by changing each non-zero value to an uncertain number with multiplicative uncertainty p, represented by N samples, i.e., p = 0.1 means that the value is multiplied by a N numbers between 0.9 and 1.1.\n\nparameters and variables indicate whether to fuzz parameters and state variables, respectively.\n\nThis function modifies all variables the same way. For more fine-grained control, load the MonteCarloMeasurements package and use the Particles type directly, followed by MonteCarloMeasurements.particle_dict2dict_vec(op), i.e., the following makes uncertain_var uncertain with a 10% uncertainty:\n\nusing MonteCarloMeasurements\nop = ModelingToolkit.defaults(sys)\nop[uncertain_var] = op[uncertain_var] * Particles(10, Uniform(0.9, 1.1))\nops = MonteCarloMeasurements.particle_dict2dict_vec(op)\nbatch_ss(model, inputs, outputs, ops)\n\nIf you have more than one uncertain parameter, it's important to use the same number of particles for all of them (10 in the example above).\n\nTo make use of this function in trajectory_ss, pass something like\n\nfuzzer = op -> ControlSystemsMTK.fuzz(op, 0.02; N=10)\n\nto fuzz each operating point 10 times with a 2% uncertainty. The resulting number of operating points will increase by 10x.\n\n\n\n\n\n","category":"function"},{"location":"batch_linearization/#Batch-Linearization-and-gain-scheduling","page":"Batch linearization and gain scheduling","title":"Batch Linearization and gain scheduling","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"This example will demonstrate how to linearize a nonlinear ModelingToolkit model in multiple different operating points, and some tools to work with groups of linear models representing the same system in different operating points. We'll end with designing and simulating a gain-scheduled controller, i.e., a nonlinear controller created as an interpolation between linear controllers.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"note: What is an operating point?\nAn operating point is typically understood as a tuple of the form (x u), where x is the state vector and u is the input vector. However, we may choose to include parameters p in the operating point as well. This may be useful when some parameters are uncertain or time varying, and we want to perform analysis over multiple possible parameter values.","category":"page"},{"location":"batch_linearization/#System-model","page":"Batch linearization and gain scheduling","title":"System model","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"The model will be a simple Duffing oscillator:","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using ControlSystemsMTK, ModelingToolkit, MonteCarloMeasurements, ModelingToolkitStandardLibrary.Blocks\nusing ModelingToolkit: getdefault\nunsafe_comparisons(true)\n\n# Create a model\n@parameters t k=10 k3=2 c=1\n@variables x(t)=0 [bounds = (-0.5, 1.5)]\n@variables v(t)=0\n\nD = Differential(t)\n\n@named y = Blocks.RealOutput()\n@named u = Blocks.RealInput()\n\neqs = [D(x) ~ v\n       D(v) ~ -k * x - k3 * x^3 - c * v + 10u.u\n       y.u ~ x]\n\n\n@named duffing = ODESystem(eqs, t, systems=[y, u], defaults=[u.u => 0])","category":"page"},{"location":"batch_linearization/#Batch-linearization","page":"Batch linearization and gain scheduling","title":"Batch linearization","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"To perform batch linearization, we create a vector of operating points, and then linearize the model around each of these points. The function batch_ss does this for us, and returns a vector of StateSpace models, one for each operating point. An operating point is a Dict that maps variables in the MTK model to numerical values. In the example below, we simply sample the variables uniformly within their bounds specified when we created the variables (normally, we might want to linearize on stationary points)","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"N = 16 # Number of samples\nxs = range(getbounds(x)[1], getbounds(x)[2], length=N)\nops = Dict.(x .=> xs)","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Just like ModelingToolkit.linearize, batch_ss takes the set of inputs and the set of outputs to linearize between.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Ps, ssys = batch_ss(duffing, [u.u], [y.u], ops)\nnothing # hide","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Plotting functions like bodeplot accept vectors of systems, so this works","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using ControlSystemsBase, Plots\nw = exp10.(LinRange(-2, 3, 200))\nbodeplot(Ps, w, legend=false)","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"We can also convert the vector of system models to a single model with RobustAndOptimalControl.ss2particles, which will convert the coefficients of the state space models to MonteCarloMeasurements.Particles objects.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using RobustAndOptimalControl\nP = RobustAndOptimalControl.ss2particles(Ps) # convert to a single StateSpace system with `Particles` as coefficients.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"notice how some coefficients are plotted like uncertain numbers -13.8 ± 4.3. We can plot such models as well:","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"bodeplot(P, w, legend=:bottomright) # Should look similar to the one above","category":"page"},{"location":"batch_linearization/#Controller-tuning","page":"Batch linearization and gain scheduling","title":"Controller tuning","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Let's also do some controller tuning for the linearized models above. The function batch_tune is not really required here, but it shows how we might go about building more sophisticated tools for batch tuning. In this example, we will tune a PID controller using the function loopshapingPID. Note, this procedure is not limited to tuning a gain-scheduled PID controller, it should work for gain-scheduling of any LTI controller. ","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"function batch_tune(f, Ps)\n    f.(Ps)\nend\n\nCs = batch_tune(Ps) do P\n    C, kp, ki, kd, fig, CF = loopshapingPID(P, 7; Mt=1.2, Tf = 1/100)\n    ss(CF)\nend\n\nP = RobustAndOptimalControl.ss2particles(Ps)\nC = RobustAndOptimalControl.ss2particles(Cs)\n\nnyquistplot(P * C,\n            w,\n            ylims = (-10, 2),\n            xlims = (-8, 5),\n            points = true,\n            Ms_circles = [1.5, 2],\n            Mt_circles = [1.2])","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Above, we plotted the Nyquist curve of the loop-transfer function for all system realizations. RobustAndOptimalControl.jl has some facilities for fitting circles around the Nyquist curve for uncertain systems, which we could use here:","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"centers, radii = fit_complex_perturbations(P * C, w; relative = false, nominal = :center)\nnyquistcircles!(w, centers, radii, ylims = (-5, 1), xlims = (-3, 4))","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"some methods for robust control operate on such circles. Notice how the circles are conservative in many cases, this is typically due to the gain varying between the models for the same phase.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"If you plot the Nyquist curve using the plotly() backend rather than the default gr() backend used here, you can hover the mouse over the curves and see which frequency they correspond to etc. ","category":"page"},{"location":"batch_linearization/#Gain-scheduling","page":"Batch linearization and gain scheduling","title":"Gain scheduling","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Above, we tuned one controller for each operating point, wouldn't it be nice if we had some features to simulate a gain-scheduled controller that interpolates between the different controllers depending on the operating pont? GainScheduledStateSpace is such a thing, we show how to use it below. For fun, we simulate some reference step responses for each individual controller in the array Cs and end with simulating the gain-scheduled controller.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using OrdinaryDiffEq\nusing DataInterpolations # Required to interpolate between the controllers\n@named fb  = Blocks.Add(k2=-1)\n@named ref = Blocks.Square(frequency=1/6, amplitude=0.5, offset=0.5, start_time=1)\n@named F   = Blocks.SecondOrder(w=15, d=1) # A reference pre-filter\nconnect    = ModelingToolkit.connect\n\nclosed_loop_eqs = [\n    connect(ref.output, F.input)\n    connect(F.output,  :r, fb.input1) # Add an analysis point :r\n    connect(duffing.y, :y, fb.input2) # Add an analysis point :y\n]\nplot(layout=2)\n\n# Simulate each individual controller\nfor C in Cs\n    @named Ci = ODESystem(C)\n    eqs = [\n        closed_loop_eqs\n        connect(fb.output, Ci.input)\n        connect(Ci.output, duffing.u)\n    ]\n    @named closed_loop = ODESystem(eqs, t, systems=[duffing, Ci, fb, ref, F])\n    prob = ODEProblem(structural_simplify(closed_loop), [F.xd => 0], (0.0, 8.0))\n    sol = solve(prob, Rodas5P(), abstol=1e-8, reltol=1e-8)\n    plot!(sol, idxs=[duffing.y.u, duffing.u.u], layout=2, lab=\"\")\nend\n\n# Simulate gain-scheduled controller\n@named Cgs = GainScheduledStateSpace(Cs, xs, interpolator=LinearInterpolation)\neqs = [\n    closed_loop_eqs\n    connect(fb.output, Cgs.input)\n    connect(Cgs.output, duffing.u)\n    connect(duffing.y, Cgs.scheduling_input) # Don't forget to connect the scheduling variable!\n]\n@named closed_loop = ODESystem(eqs, t, systems=[duffing, Cgs, fb, ref, F])\nprob = ODEProblem(structural_simplify(closed_loop), [F.xd => 0], (0.0, 8.0))\nsol = solve(prob, Rodas5P(), abstol=1e-8, reltol=1e-8, initializealg=NoInit())\nplot!(sol, idxs=[duffing.y.u, duffing.u.u], l=(2, :red), lab=\"Gain scheduled\")\nplot!(sol, idxs=F.output.u, l=(1, :black, :dash, 0.5), lab=\"Ref\")","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"If everything worked as expected, the gain-scheduled controller should perform better than each of the included controllers individually. ","category":"page"},{"location":"batch_linearization/#C-Code-generation","page":"Batch linearization and gain scheduling","title":"C-Code generation","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"We can generate C-code to interpolate our controller using the function SymbolicControlSystems.print_c_array from SymbolicControlSystems.jl. If the controller is a standard ControlSystemsBase.StateSpace object, a function that filters the input through the controller can be generated by calling SymbolicControlSystems.ccode. But if the controller is a vector of controllers representing a gain-scheduled controller, a function that creates the interpolated dynamics is written. In the code below, we shorten the vector of controllers to make the generated C-code easier to read by passing Cs[1:7:end] and xs[1:7:end]","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using SymbolicControlSystems, ControlSystemsBase\nCs_disc = c2d.(Cs, 0.05, :tustin) # Discretize the controller before generating code\ncode = SymbolicControlSystems.print_c_array(stdout, Cs_disc[1:7:end], xs[1:7:end], \"Cs\")","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"The generated code starts by defining the interpolation vector xs, this variable is called Cs_interp_vect in the generated code. The code then defines all the A matrices as a 3-dimensional array, followed by a function that performs the interpolation interpolate_Cs_A. This function takes the output array as the first argument, a pointer to the 3D array with interpolation matrices, the interpolation vector as well as the interpolation variable t, in this document called v. The same code is then repeated for the matrices BCD as well if they require interpolation (if they are all the same, no interpolation code is written). ","category":"page"},{"location":"batch_linearization/#Linearize-around-a-trajectory","page":"Batch linearization and gain scheduling","title":"Linearize around a trajectory","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"We can linearize around a trajectory obtained from solve using the function trajectory_ss. We provide it with a vector of time points along the trajectory at which to linearize, and in this case we specify the inputs and outputs to linearize between as analysis points :r and :y.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"timepoints = 0:0.01:8\nPs2, ssys = trajectory_ss(closed_loop, :r, :y, sol; t=timepoints)\nbodeplot(Ps2, w, legend=false)","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Internally, trajectory_ss works very much the same as batch_ss, but constructs operating points automatically along the trajectory. This requires that the solution contains the states of the simplified system, accessible through the idxs argument like sol(t, idxs=x). By linearizing the same system as we simulated, we ensure that this condition holds, doing so requires that we specify the inputs and outputs as analysis points rather than as variables.","category":"page"},{"location":"batch_linearization/#Summary","page":"Batch linearization and gain scheduling","title":"Summary","text":"","category":"section"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"We have seen how to","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Perform linearization of a nonlinear ModelingToolkit model in multiple different operating points\nHandle arrays of models or models with Particles as coefficients\nSimulate a gain-scheduled controller that interpolates between linear controllers\nWrite C-code to perform the interpolation of the controllers","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"Batch linearization in multiple different operating points is an intuitive way to perform analysis of a nonlinear control system. Gain-scheduling is an equally intuitive way of realizing a nonlinear controller. Care should be taken to ensure that the scheduling variable does not change too fast such that the linear assumption at each instance of time is not violated.","category":"page"},{"location":"batch_linearization/","page":"Batch linearization and gain scheduling","title":"Batch linearization and gain scheduling","text":"using Test\n@test sol(6.99, idxs=closed_loop.duffing.y.u) ≈ 0.0 atol=0.01","category":"page"},{"location":"#ControlSystemsMTK.jl","page":"Home","title":"ControlSystemsMTK.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ControlSystemsMTK provides an interface between ControlSystems.jl and ModelingToolkit.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the videos below for examples of using ControlSystems and ModelingToolkit together.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/favQKOyyx4o\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/Effifd9Th9I\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add ControlSystemsMTK","category":"page"},{"location":"#From-ControlSystems-to-ModelingToolkit","page":"Home","title":"From ControlSystems to ModelingToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simply calling ODESystem(sys) converts a StateSpace object from ControlSystems into the corresponding ModelingToolkitStandardLibrary.Blocks.StateSpace. If sys is a named statespace object, the names of inputs and outputs will be retained in the ODESystem as connectors, that is, if my_input is an input variable in the named statespace object, my_input will be a connector of type RealInput in the resulting ODESystem. Names of state variables are currently ignored.","category":"page"},{"location":"#Example:","page":"Home","title":"Example:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using ControlSystemsMTK, ControlSystemsBase, ModelingToolkit, RobustAndOptimalControl\n\njulia> P0 = tf(1.0, [1, 1])  |> ss\nStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model\n\njulia> @named P = ODESystem(P0)\nModel P with 2 equations\nStates (3):\n  x[1](t) [defaults to 0.0]\n  input₊u(t) [defaults to 0.0]\n  output₊u(t) [defaults to 0.0]\nParameters (0):\n\njulia> equations(P)\n2-element Vector{Equation}:\n Differential(t)(x[1](t)) ~ input₊u(t) - x[1](t)\n output₊u(t) ~ x[1](t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To connect P to the input and output of P, use the connectors P.input and P.output. If the inputs or outputs are multivariable, there are additional scalar connectors for each input/output variable respectively. ","category":"page"},{"location":"#Example-with-named-signals","page":"Home","title":"Example with named signals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following creates a named statespace system with named inputs u = :torque and outputs y = [:motor_angle, :load_angle]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ControlSystemsMTK, ControlSystemsBase, ModelingToolkit, RobustAndOptimalControl\n\nP = named_ss(DemoSystems.double_mass_model(outputs = [1,3]), u=:torque, y=[:motor_angle, :load_angle])","category":"page"},{"location":"","page":"Home","title":"Home","text":"When we convert this system to an ODESystem, we get a system with connectors P.torque and P.motor_angle, in addition to the standard connectors P.input and P.output:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@named P_ode = ODESystem(P)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, P.torque is equal to P.input, so you may choose to connect to either of them. However, since the output is multivariable, the connector P.output represents both outputs, while P.motor_angle and P.load_angle represent the individual scalar outputs.","category":"page"},{"location":"#From-ModelingToolkit-to-ControlSystems","page":"Home","title":"From ModelingToolkit to ControlSystems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An ODESystem can be converted to a named statespace object from RobustAndOptimalControl.jl by calling named_ss","category":"page"},{"location":"","page":"Home","title":"Home","text":"named_ss(ode_sys, inputs, outputs; op)","category":"page"},{"location":"","page":"Home","title":"Home","text":"this performs a linearization of ode_sys around the operating point op (defaults to the default values of all variables in ode_sys).","category":"page"},{"location":"#Example:-2","page":"Home","title":"Example:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using P from above:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @unpack input, output = P;\n\njulia> P02_named = named_ss(P, [input.u], [output.u])\nNamedStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model\nWith state  names: x[1](t)\n     input  names: input₊u(t)\n     output names: output₊u(t)\n\njulia> using Plots;\n\njulia> bodeplot(P02_named)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: plot)","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ss(P02_named) # Convert to a statespace system without names\nStateSpace{Continuous, Float64}\nA = \n -1.0\nB = \n 1.0\nC = \n 1.0\nD = \n 0.0\n\nContinuous-time state-space model","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit tends to give weird names to inputs and outputs etc., to access variables easily, named_ss implements prefix matching, so that you can access the mapping from input₊u(t) to output₊u(t) by","category":"page"},{"location":"","page":"Home","title":"Home","text":"P02_named[:out, :in]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To learn more about linearization of ModelingToolkit models, see the video below","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/-XOux-2XDGI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"#Symbolic-linearization-and-code-generation","page":"Home","title":"Symbolic linearization and code generation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit has facilities for symbolic linearization that can be used on sufficiently simple systems. The function linearize_symbolic behaves similarly to linearize but returns symbolic matrices A,B,C,D rather than numeric. A StateSpace system with such symbolic coefficients can be used to generate a function that takes parameter values and outputs a statically sized statespace system with numeric matrices. An example follows","category":"page"},{"location":"#System-model","page":"Home","title":"System model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We start by building a system mode, we'll use a model of two masses connected by a flexible transmission","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ControlSystemsMTK, ControlSystemsBase\nusing ModelingToolkit, OrdinaryDiffEq, LinearAlgebra\nusing ModelingToolkitStandardLibrary.Mechanical.Rotational\nusing ModelingToolkitStandardLibrary.Blocks: Sine\nusing ModelingToolkit: connect\nimport ModelingToolkitStandardLibrary.Blocks\nt = Blocks.t\n\n# Parameters\nm1 = 1\nm2 = 1\nk = 1000 # Spring stiffness\nc = 10   # Damping coefficient\n@named inertia1 = Inertia(; J = m1, w=0)\n@named inertia2 = Inertia(; J = m2, w=0)\n@named spring = Spring(; c = k)\n@named damper = Damper(; d = c)\n@named torque = Torque(use_support=false)\n\nfunction SystemModel(u=nothing; name=:model)\n    @named sens = Rotational.AngleSensor()\n    eqs = [\n        connect(torque.flange, inertia1.flange_a)\n        connect(inertia1.flange_b, spring.flange_a, damper.flange_a)\n        connect(inertia2.flange_a, spring.flange_b, damper.flange_b)\n        connect(inertia2.flange_b, sens.flange)\n    ]\n    if u !== nothing \n        push!(eqs, connect(u.output, :u, torque.tau))\n        return @named model = ODESystem(eqs, t; systems = [sens, torque, inertia1, inertia2, spring, damper, u])\n    end\n    ODESystem(eqs, t; systems = [sens, torque, inertia1, inertia2, spring, damper], name)\nend\n\nmodel = SystemModel() |> complete","category":"page"},{"location":"#Numeric-linearization","page":"Home","title":"Numeric linearization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can linearize this model numerically using named_ss, this produces a NamedStateSpace{Continuous, Float64}","category":"page"},{"location":"","page":"Home","title":"Home","text":"lsys = named_ss(model, [model.torque.tau.u], [model.inertia1.phi, model.inertia2.phi], op = Dict(model.torque.tau.u => 0))","category":"page"},{"location":"#Symbolic-linearization","page":"Home","title":"Symbolic linearization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If we instead call linearize_symbolic and pass the jacobians into ss, we get a StateSpace{Continuous, Num}","category":"page"},{"location":"","page":"Home","title":"Home","text":"mats, simplified_sys = ModelingToolkit.linearize_symbolic(model, [model.torque.tau.u], [model.inertia1.phi, model.inertia2.phi])\nsymbolic_sys = ss(mats.A, mats.B, mats.C, mats.D)","category":"page"},{"location":"#Code-generation","page":"Home","title":"Code generation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"That's pretty cool, but even nicer is to generate some code for this symbolic system. Below, we use build_function to generate a function that takes a numeric vector x representing the values of the state, and a vector of parameters, and returns a StaticStateSpace{Continuous, Float64}. We pass the keyword argument force_SA=true to build_function to get an allocation-free function. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"defs = ModelingToolkit.defaults(simplified_sys)\ndefs = merge(Dict(unknowns(model) .=> 0), defs)\nx, pars = ModelingToolkit.get_u0_p(simplified_sys, defs, defs) # Extract the default state and parameter values\n\nfun = Symbolics.build_function(symbolic_sys, unknowns(simplified_sys), ModelingToolkit.parameters(simplified_sys);\n    expression = Val{false}, # Generate a compiled function rather than a Julia expression\n    force_SA   = true,       # Use static arrays instead of regular arrays, for higher performance 🚀\n)\n\nstatic_lsys = fun(x, pars) # We now have a function that takes state and parameters and returns the linearized system!","category":"page"},{"location":"","page":"Home","title":"Home","text":"It's pretty fast","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BenchmarkTools\n@btime $fun($x, $pars)\n8.484 ns (0 allocations: 0 bytes)","category":"page"},{"location":"","page":"Home","title":"Home","text":"faster than multiplying two integers in python.","category":"page"},{"location":"#C-code-generation","page":"Home","title":"C-code generation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you prefer to get C-code for deployment onto an embedded target, the types from Symbolics can be converted to SymPy symbols using symbolics_to_sympy. After this, the function SymbolicControlSystems.ccode is called to generate the C-code. The symbols that are present in the system will be considered input arguments in the generated code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SymbolicControlSystems\nAsp = SymbolicControlSystems.Sym.(Symbolics.symbolics_to_sympy.(mats.A))\nBsp = SymbolicControlSystems.Sym.(Symbolics.symbolics_to_sympy.(mats.B))\nCsp = SymbolicControlSystems.Sym.(Symbolics.symbolics_to_sympy.(mats.C))\nDsp = SymbolicControlSystems.Sym.(Symbolics.symbolics_to_sympy.(mats.D))\nsys_sp = ss(Asp, Bsp, Csp, Dsp)\nsympars_sp = Symbolics.symbolics_to_sympy.(sympars)\n\ndiscrete_sys_sp = c2d(sys_sp, 0.01, :tustin) # We can only generate C-code for discrete systems\n\ncode = SymbolicControlSystems.ccode(discrete_sys_sp; function_name=\"perfectly_grilled_hotdogs\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This produces the following code, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"#include <stdio.h>\n#include <math.h>\n\nvoid perfectly_grilled_hotdogs(double *y, double u, double damper_d, double inertia1_J, double inertia2_J, double spring_c) {\n    static double x[4] = {0};  // Current state\n    double xp[4] = {0};        // Next state\n    int i;\n\n    // Common sub expressions. These are all called xi, but are unrelated to the state x\n    double x0 = inertia2_J*spring_c;\n    double x1 = 2.0*x0;\n    double x2 = 200.0*damper_d;\n    double x3 = inertia2_J*x2;\n    double x4 = x0 + x3;\n    double x5 = 40000.0*inertia2_J;\n    double x6 = inertia1_J*x5;\n    double x7 = inertia1_J*spring_c;\n    double x8 = inertia1_J*x2;\n    double x9 = x7 + x8;\n    double x10 = x6 + x9;\n    double x11 = 1.0/(x10 + x4);\n    double x12 = x11*x[2];\n    double x13 = damper_d*inertia1_J;\n    double x14 = inertia1_J*inertia2_J;\n    double x15 = 1.0/(damper_d*x5 + 200.0*x0 + 40000.0*x13 + 8000000.0*x14 + 200.0*x7);\n    double x16 = spring_c + x2;\n    double x17 = 0.01*u;\n    double x18 = x17*(x16 + x5);\n    double x19 = 20000.0*damper_d;\n    double x20 = 1.0/(inertia1_J*x19 + inertia2_J*x19 + 100.0*x0 + 4000000.0*x14 + 100.0*x7);\n    double x21 = x20*x[3];\n    double x22 = x20*x[1];\n    double x23 = -x0;\n    double x24 = x10 + x3;\n    double x25 = x11*x[0];\n    double x26 = x0*x12;\n    double x27 = x11*x[3];\n    double x28 = x11*x[1];\n    double x29 = 2.0*x7;\n    double x30 = x16*x17;\n    double x31 = x4 + x6;\n    double x32 = -x7;\n    double x33 = x31 + x8;\n    double x34 = x25*x7;\n    double x35 = x15*x[3];\n    double x36 = x15*x[1];\n    double x37 = 0.005*u*x15/inertia1_J;\n\n    // Advance the state xp = Ax + Bu\n    xp[0] = (x1*x12 + x10*x22 + x15*x18 + x21*x4 + x25*(x23 + x24));\n    xp[1] = (-400.0*x0*x25 + x11*x18 + 400.0*x26 + x27*(400.0*damper_d*inertia2_J + x1) + x28*(x10 + x23 - x3));\n    xp[2] = (x12*(x32 + x33) + x15*x30 + x21*x31 + x22*x9 + x25*x29);\n    xp[3] = (x11*x30 - 400.0*x12*x7 + x27*(x31 + x32 - x8) + x28*(400.0*x13 + x29) + 400.0*x34);\n\n    // Accumulate the output y = C*x + D*u\n    y[0] = (x10*x36 + x10*x37 + x24*x25 + x26 + x35*x4);\n    y[1] = (x12*x33 + x31*x35 + x34 + x36*x9 + x37*x9);\n\n    // Make the predicted state the current state\n    for (i=0; i < 4; ++i) {\n        x[i] = xp[i];\n    }\n\n}","category":"page"},{"location":"#Additional-resources","page":"Home","title":"Additional resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modeling for control using ModelingToolkit tutorial\nLinear Analysis tools in ModelingToolkit\nVideo demo using ControlSystems and MTK","category":"page"},{"location":"#Internals:-Transformation-of-non-proper-models-to-proper-statespace-form","page":"Home","title":"Internals: Transformation of non-proper models to proper statespace form","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For some models, ModelingToolkit will fail to produce a proper statespace model (a non-proper model is differentiating the inputs, i.e., it has a numerator degree higher than the denominator degree if represented as a transfer function) when calling linearize. For such models, given on the form dot x = Ax + Bu + bar B dot u we create the following augmented descriptor model","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nsX = Ax + BU + sbar B U \nX_u = U\ns(X - bar B X_u) = AX + BU \ns beginbmatrixI  -bar B  0  0 endbmatrix = \nbeginbmatrix A  0  0  -Iendbmatrix\nbeginbmatrixX  X_u endbmatrix + \nbeginbmatrix B  I_uendbmatrix U \nsE = A_e x_e + B_e u\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where X_u is a new algebraic state variable and I_u is a selector matrix that picks out the differentiated inputs appearing in dot u (if all inputs appear, I_u = I).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This model may be converted to a proper statespace model (if the system is indeed proper) using DescriptorSystems.dss2ss. All of this is handled automatically by named_ss.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Summary: If you get the error message","category":"page"},{"location":"","page":"Home","title":"Home","text":"Input derivatives appeared in expressions (-gz\\gu != 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Switch from calling linearize to calling named_ss with exactly the same input arguments, and then pass the argument allow_input_derivatives = true to named_ss.","category":"page"}]
}
